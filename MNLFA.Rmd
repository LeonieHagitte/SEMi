---
title: "MNLFA"
author: "Leonie H."
date: "2023-08-30"
output: html_document
---

```{r setup, include=FALSE}
library(haven)
library(tidyverse)
library(tidyr)
library(mokken)
library(OpenMx)
library(ggplot2)
library(lavaan)
library(semTools)
library(semPlot)
library(psych)
library(GPArotation)
library(corrplot)
library(stats)
library(dplyr)
library(usethis)
library(gitcreds)
library(gh)
library(repro)

```

```{r}
#measurement-models CTT
casp_g.tau.kon.mod <- 'control  =~ q2_a + q2_b + q2_c
                       autonomy  =~ q2_d + q2_e + q2_f
                       pleasure  =~ q2_g + q2_h + q2_i
                       self_real  =~ q2_j + q2_k + q2_l
                     '
casp_g.tau.kon.fit<- cfa(casp_g.tau.kon.mod, casp,
                        meanstructure = TRUE,estimator="MLR")
summary(casp_g.tau.kon.fit,fit.measures=TRUE,standardized=TRUE)

# Loadings set to be equal
casp_g.ess.tau.q.mod <- 'control  =~ q2_a + 1*q2_b + 1*q2_c
                         autonomy  =~ q2_d + 1*q2_e + 1*q2_f
                         pleasure  =~ q2_g + 1*q2_h + 1*q2_i
                         self_real  =~ q2_j + 1*q2_k + 1*q2_l
                        '
casp_g.ess.tau.q.fit<- cfa(casp_g.ess.tau.q.mod, casp,
                           meanstructure = TRUE,estimator="MLR")
summary(casp_g.ess.tau.q.fit,fit.measures=TRUE,standardized=TRUE)

lavTestLRT(casp_g.tau.kon.fit, casp_g.ess.tau.q.fit)

```
The respective model fits and the LRT indicate, that a tau congeneric model 
seems to be apropriate.Therefor I continue using that respective model for the 
following analysis.

# Secondorder CFA - the model
# latent variable definitions
```{r}
casp_g.tau.kon.mod <- 'control  =~ q2_a + q2_b + q2_c
                       autonomy  =~ q2_d + q2_e + q2_f
                       pleasure  =~ q2_g + q2_h + q2_i
                       self_real  =~ q2_j + q2_k + q2_l
                     '
#CFA
casp_cfa_mod <- cfa(casp_g.tau.kon.mod, casp, estimator="MLR") 
summary(casp_cfa_mod,fit.measures=TRUE,standardized=TRUE)
mod_i_m2a <- modificationIndices(casp_cfa_mod, sort=TRUE, minimum.value = 3)
view(mod_i_m2a)
```


## merge demographic variables to items:
```{r}
df1 <- casp %>% 
  full_join(
    demo, by="mergeid"
  ) %>% 
  dplyr::select(age, matches("^cC|^cA|^cP|^cS"))

# Storing the names of variables (items) as `manVars`:
manVars <- colnames(df1[,-c(1:2)])

# Storing the number of variables (items) as `nv`:
nv <- length(manVars)
```

## Missing Values
```{r missing}
# Define Missing Codes. Refer to the SHARE release guide for more detail:
missing_codes <- c(-1, -2, -3, -7, -9, -10, -11, -12, -14, -15, -16)

df2 <- df1 %>%
  mutate_all(~ifelse(. %in% missing_codes, NA, .))

# Check number of subjects with NAs on all CASP-12:
n_missings <- 
  sum(apply(df2[manVars], 1, function(row) all(is.na(row))))

df3 <- df2 %>% 
  filter(rowSums(is.na(.[manVars])) < length(manVars)) %>% 
# Remove missings on moderators gender and `age` (year of birth) and bfi items
  filter(complete.cases(age))
```

## Recode Items
```{r}
df4 <- df3 %>% 
  # Recode negative items of the Casp-12 questionnaire:
  mutate(
    cA1 = 5 - cA1,
    cP1 = 5 - cP1,
    cP2 = 5 - cP2,
    cP3 = 5 - cP3,
    cS1 = 5 - cS1,
    cS2 = 5 - cS2,
    cS3 = 5 - cS3,
  # Recode gender variable to `male` with 1 indicating male and 0 female:
    age = 2017 - age
  ) %>%  
  # Order variables:
  dplyr::select(age, everything())

# Standardize all variables
df_z <- df4 %>% 
  mutate_if(names(.) != "male", scale)
```

## Descriptives
```{r}
hist(df4$age)

cor <- cor(df4, use= "pairwise.complete.obs")

corrplot(cor, method = "color")
```

```{r}
# Saving data frame as mx object:
mxdf1 <- mxData(observed = df_z, type = "raw")
```
#################################
# With Country and Age
```{r}
## Specify matrices for configural model
matT0 <- mxMatrix(type="Full", nrow=1, ncol=12,#baseline intercepts
                  free=TRUE,
                  values=1,
                  name="matT0")

matB1 <- mxMatrix(type = "Full", nrow = 1, ncol = nv,  # full matrix of background effects
                  free = TRUE,
                  values = 0,
                  name = "matB1")
matB2 <- mxMatrix(type = "Full", nrow = 1, ncol = nv,
                  free = TRUE,
                  values = 0,
                  name = "matB2")

matL0 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,  # loadings ############
                  free = c(rep(c(TRUE, FALSE,FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE,FALSE, FALSE), 3),
                           rep(c(FALSE,FALSE,TRUE,FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE,TRUE), 3)
                           ),
                  values = c(rep(c(1, 0, 0, 0), 3),
                             rep(c(0, 1, 0, 0), 3),
                             rep(c(0, 0, 1, 0), 3),
                             rep(c(0, 0, 0, 1), 3)),
                  byrow = TRUE,
                  name = "matL0")

matC1 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,  # direct effects of age and country
                  free = c(rep(c(TRUE, FALSE, FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE, FALSE, FALSE), 3),
                           rep(c(FALSE, FALSE, TRUE, FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE, TRUE), 3)),
                  values = 0,
                  byrow = TRUE,
                  name = "matC1")

matC2 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,
                  free = c(rep(c(TRUE, FALSE, FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE, FALSE, FALSE), 3),
                           rep(c(FALSE, FALSE, TRUE, FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE, TRUE), 3)),
                  values = 0,
                  byrow = TRUE,
                  name = "matC2")
# matrix for residual covariance at baseline
matE0 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 1,
                  name = "matE0")
# matrix for residual covariance of age
matD1 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 0,
                  name = "matD1")
# matrix for residual covariance of country
matD2 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 0,
                  name = "matD2")

matP0 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,#variances
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = c(1, 0, 0, 0,
                             0, 1, 0, 0,
                             0, 0, 1, 0,
                             0, 0, 0, 1),
                  name = "matP0")
matH1 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = 0,
                  name = "matH1")
matH2 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = 0,
                  name = "matH2")

matA0 <- mxMatrix(type="Full", nrow=4, ncol=1,#factor means not estimated
                  free=FALSE,
                  values= c(0, 0, 0, 0),
                  name="matA0")
matG1 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=FALSE, # to identify the model config to zero
                  values=0,
                  name="matG1")
matG2 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=FALSE, # to identify the model config to zero
                  values=0,
                  name="matG2")

matV1 <- mxMatrix(type="Full", nrow=1, ncol=1, 
                  free=FALSE, 
                  labels="data.age2004", 
                  name = "age")
matV2 <- mxMatrix(type="Full", nrow=1, ncol=1, 
                  free=FALSE, 
                  labels="data.country", 
                  name = "country")

matIa <- mxMatrix(type="Diag", nrow=4, ncol=4, 
                  free=FALSE,
                  values=1, 
                  name="matIa")
matIb <- mxMatrix(type="Full", nrow=4, ncol=4, 
                  free=FALSE, 
                  values=c(0,1,1,1,
                           1,0,1,1,
                           1,1,0,1,
                           1,1,1,0),
                  name="matIb")
```

## Specify algebra for the dependent parameters
```{r}
matT <- mxAlgebra(expression=matT0+matB1*country+matB2*age, 
                  name="matT")
matL <- mxAlgebra(expression=matL0+matC1*country+matC2*age, 
                  name="matL")
matE <- mxAlgebra(expression=matE0*exp(matD1*country+matD2*age), 
                  name="matE")
matA <- mxAlgebra(expression=matA0+matG1*country+matG2*age, 
                  name="matA")

## Specify algebra for covariance matrix of factors (transformed to ensure positive definite matrices)
matVar <- mxAlgebra(expression=(matP0*exp(matH1*country+matH2*age)), 
                    name="matVar")
matR <- mxAlgebra(expression=(exp(2*(matP0+matH1*country+matH2*age))-1)/
                    (exp(2*(matP0+matH1*country+matH2*age))+1), 
                  name="matR")
matCov <- mxAlgebra(expression=(matIa*sqrt(matVar))%*%matR%*%(matIa*sqrt(matVar)), 
                    name="matCov")
matP <- mxAlgebra(expression=matIa*matVar+matIb*matCov, 
                  name="matP")

## Specify model-implied matrices
matC <- mxAlgebra(expression=matL%*%matP%*%t(matL)+matE, 
                  name="matC") 
matM <- mxAlgebra(expression=matT+t(matL%*%matA), 
                  name="matM") 

## Specify expectation and fit function
expF <- mxExpectationNormal(covariance="matC", 
                            means="matM",
                            dimnames=manVars)
fitF <- mxFitFunctionML() 
```

## Make mxModel object and run the model
```{r}
modConfig <- mxModel(model="Configural", 
                     matT, matT0, matB1, matB2,
                     matL, matL0, matC1, matC2, 
                     matE, matE0, matD1, matD2,
                     matP, matP0, matH1, matH2,
                     matA, matA0, matG1, matG2,  
                     matIa, matIb, matV1, matV2, 
                     matVar, matR, matCov, matM, matC, 
                     expF, fitF, mxdata1)


fitConfig <- mxRun(modConfig)
summary(fitConfig) 
```

```{r}
#mxCheckIdentification(modConfig) #commented out for knitting

```

### Specify matrices scalar model
```{r}
matB1 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                  free=FALSE,
                  values=0,
                  name="matB1")
matB2 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                  free=FALSE,
                  values=0,
                  name="matB2")
matC1 <- mxMatrix(type="Full", nrow=12, ncol=4,
                  free=FALSE,
                  values=0,
                  name="matC1")
matC2 <- mxMatrix(type="Full", nrow=12, ncol=4,
                  free=FALSE,
                  values=0,
                  name="matC2")

matH1 <- mxMatrix(type="Symm", nrow=4, ncol=4,
                  free=TRUE, 
                  values=0,
                  name="matH1")
matH2 <- mxMatrix(type="Symm", nrow=4, ncol=4,
                  free=TRUE, 
                  values=0,
                  name="matH2")

matG1 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=TRUE, 
                  values=0,
                  name="matG1")
matG2 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=TRUE, 
                  values=0,
                  name="matG2")
```

## Make mxModel object and run the model
```{r}
modScalar <- mxModel(model="Scalar", 
                     matT, matT0, matB1, matB2,
                     matL, matL0, matC1, matC2, 
                     matE, matE0, matD1, matD2,
                     matP, matP0, matH1, matH2,
                     matA, matA0, matG1, matG2,  
                     matIa, matIb, matV1, matV2, 
                     matVar, matR, matCov, matM, matC, 
                     expF, fitF, mxdata1)
fitScalar <- mxRun(modScalar)
summary(fitScalar)
```

## Compare fit of unconstrained model with constrained model
```{r}
miTest <- mxCompare(fitConfig, fitScalar)
#miTest[2,c(7,8,9)] #values not adjusted yet
#miTest$p[2] < 0.001
```

## Step 4: Select anchor indicators
```{r}
## Run unconstrained model for each indicator
fitAbo <- list()

for (i in 1:12) {
  freeparT <- matrix(FALSE, nrow = 1, ncol = 12)
  freeparT[i] <- TRUE
  
  freeparL <- matrix(FALSE, nrow = 12, ncol = 4)  # Adjusted for four number-spaces
  
  # Assign the corresponding number-space based on the row index
  if (i %in% 1:3) {
    freeparL[i, 1] <- TRUE  # First number-space
  } else if (i %in% 4:6) {
    freeparL[i, 2] <- TRUE  # Second number-space
  } else if (i %in% 7:9) {
    freeparL[i, 3] <- TRUE  # Third number-space
  } else if (i %in% 10:12) {
    freeparL[i, 4] <- TRUE  # Fourth number-space
  }       
  matB1 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                    free=freeparT,
                    values=0,
                    name="matB1")
  matB2 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                    free=freeparT,
                    values=0,
                    name="matB2")
  matC1 <- mxMatrix(type="Full", nrow=12, ncol=4,
                    free=freeparL,
                    values=0,
                    byrow=TRUE,
                    name="matC1")
  matC2 <- mxMatrix(type="Full", nrow=12, ncol=4,
                    free=freeparL,
                    values=0,
                    byrow=TRUE,
                    name="matC2")
  modAbo <- mxModel(model=paste0("All_but_", i), 
                   matT, matT0, matB1, matB2,
                   matL, matL0, matC1, matC2, 
                   matE, matE0, matD1, matD2,
                   matP, matP0, matH1, matH2,
                   matA, matA0, matG1, matG2,  
                   matIa, matIb, matV1, matV2, 
                   matVar, matR, matCov, matM, matC, 
                   expF, fitF, mxdata1)
  fitAbo[[i]] <- mxRun(modAbo)
}
```

## Compare constrained model with all unconstrained models
```{r}
anchorTest <- mxCompare(fitAbo, fitScalar)
anchorOut <- data.frame(Name=paste0("Indicator",1:12), 
                    X2=anchorTest$diffLL[seq(2,24,2)],
                    df=anchorTest$diffdf[seq(2,24,2)],
                    p=anchorTest$p[seq(2,24,2)])
anchorOut
```

## Select two indicators per factor with smallest X2 as anchor
```{r}
anchorOut[order(anchorOut$X2[1:3]),]
anchorOut[3+order(anchorOut$X2[4:6]),]
anchorOut[6+order(anchorOut$X2[7:9]),]
anchorOut[9+order(anchorOut$X2[10:12]),]

## Save anchors in object ####currently random selected
anchors1 <- c(1,2)
anchors2 <- c(4,5)
anchors3 <- c(7,8)
anchors4 <- c(10,11)

```



