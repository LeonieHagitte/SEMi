---
title: "MNLFA"
author: "Leonie H."
date: "2023-08-30"
output: html_document
---

```{r setup, include=FALSE}
library(haven)
library(tidyverse)
library(tidyr)
library(mokken)
library(OpenMx)
library(ggplot2)
library(lavaan)
library(semTools)
library(semPlot)
library(psych)
library(GPArotation)
library(corrplot)
library(stats)
library(dplyr)
library(usethis)
library(gitcreds)
library(gh)
library(repro)
library(readr)

```

## Enreading Data & Descriptives
```{r}
df4 <- read_delim("df4.csv", delim = ";", 
    escape_double = FALSE, col_types = cols(...1 = col_skip(), 
        mergeid = col_skip(), yrbirth = col_skip()), 
    trim_ws = TRUE)
View(df4)

# Convert "single" and "gender" to factors
#general_data6$single <- factor(general_data6$single, levels = c(0, 1), labels = c("No", "Yes"))
#general_data6$gender <- factor(general_data6$gender, levels = c(1, 2), labels = c("Male", "Female"))

```
################ variables not yet working ################
```{r}
#measurement-models CTT
casp_g.tau.kon.mod <- 'control  =~ cC1 + cC2 + cC3 
                       autonomy  =~ cA1 + cA2 + cA3
                       pleasure  =~ cP1 + cP2 + cP3
                       self_real  =~ cS1 + cS2 + cS3
                     '
casp_g.tau.kon.fit<- cfa(casp_g.tau.kon.mod, df4,
                        meanstructure = TRUE,estimator="MLR")
summary(casp_g.tau.kon.fit,fit.measures=TRUE,standardized=TRUE)

# Loadings set to be equal
casp_g.ess.tau.q.mod <- 'control  =~ cC1 + 1*cC2 + 1*cC3
                       autonomy  =~ cA1 + 1*cA2 + 1*cA3
                       pleasure  =~ cP1 + 1*cP2 + 1*cP3
                       self_real  =~ cS1 + 1*cS2 + 1*cS3
                     '
casp_g.ess.tau.q.fit<- cfa(casp_g.ess.tau.q.mod, df4,
                           meanstructure = TRUE,estimator="MLR")
summary(casp_g.ess.tau.q.fit,fit.measures=TRUE,standardized=TRUE)

lavTestLRT(casp_g.tau.kon.fit, casp_g.ess.tau.q.fit)

```

# Secondorder CFA - the model
# latent variable definitions
```{r}
casp_g.tau.kon.mod <- 'control  =~ cC1 + cC2 + cC3 
                       autonomy  =~ cA1 + cA2 + cA3
                       pleasure  =~ cP1 + cP2 + cP3
                       self_real  =~ cS1 + cS2 + cS3
                     '
#CFA
casp_cfa_mod <- cfa(casp_g.tau.kon.mod, df4, estimator="MLR") 
summary(casp_cfa_mod,fit.measures=TRUE,standardized=TRUE)
mod_i_m2a <- modificationIndices(casp_cfa_mod, sort=TRUE, minimum.value = 3)
view(mod_i_m2a)
```


## Descriptives
```{r}
hist(df4$age)

cor <- cor(df4, use= "pairwise.complete.obs")

corrplot(cor, method = "color")
```

```{r}
# Saving data frame as mx object:
mxdf1 <- mxData(observed = df4, type = "raw")
manVars <- colnames(df4)
nv <- length(manVars)
```
#################################
# With Gender and Age
```{r}
## Specify matrices for configural model
matT0 <- mxMatrix(type="Full", nrow=1, ncol=12,#baseline intercepts
                  free=TRUE,
                  values=1,
                  name="matT0")

matB1 <- mxMatrix(type = "Full", nrow = 1, ncol = nv,  # full matrix of background effects
                  free = TRUE,
                  values = 0,
                  name = "matB1")
matB2 <- mxMatrix(type = "Full", nrow = 1, ncol = nv,
                  free = TRUE,
                  values = 0,
                  name = "matB2")

matL0 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,  # loadings ############
                  free = c(rep(c(TRUE, FALSE, FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE, FALSE, FALSE), 3),
                           rep(c(FALSE, FALSE, TRUE, FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE, TRUE), 3)
                           ),
                  values = c(rep(c(1, 0, 0, 0), 3),
                             rep(c(0, 1, 0, 0), 3),
                             rep(c(0, 0, 1, 0), 3),
                             rep(c(0, 0, 0, 1), 3)),
                  byrow = TRUE,
                  name = "matL0")

matC1 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,  # direct effects of age and gender
                  free = c(rep(c(TRUE, FALSE, FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE, FALSE, FALSE), 3),
                           rep(c(FALSE, FALSE, TRUE, FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE, TRUE), 3)),
                  values = 0,
                  byrow = TRUE,
                  name = "matC1")

matC2 <- mxMatrix(type = "Full", nrow = 12, ncol = 4,
                  free = c(rep(c(TRUE, FALSE, FALSE, FALSE), 3),
                           rep(c(FALSE, TRUE, FALSE, FALSE), 3),
                           rep(c(FALSE, FALSE, TRUE, FALSE), 3),
                           rep(c(FALSE, FALSE, FALSE, TRUE), 3)),
                  values = 0,
                  byrow = TRUE,
                  name = "matC2")
# matrix for residual covariance at baseline
matE0 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 1,
                  name = "matE0")
# matrix for residual covariance of age
matD1 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 0,
                  name = "matD1")
# matrix for residual covariance of gender
matD2 <- mxMatrix(type = "Diag", nrow = nv, ncol = nv,  
                  free = TRUE,
                  values = 0,
                  name = "matD2")

matP0 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,#variances
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = c(1, 0, 0, 0,
                             0, 1, 0, 0,
                             0, 0, 1, 0,
                             0, 0, 0, 1),
                  name = "matP0")
matH1 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = 0,
                  name = "matH1")
matH2 <- mxMatrix(type = "Symm", nrow = 4, ncol = 4,
                  free = c(FALSE, TRUE, TRUE, TRUE,
                           TRUE, FALSE, TRUE, TRUE,
                           TRUE, TRUE, FALSE, TRUE,
                           TRUE, TRUE, TRUE, FALSE),
                  values = 0,
                  name = "matH2")

matA0 <- mxMatrix(type="Full", nrow=4, ncol=1,#factor means not estimated
                  free=FALSE,
                  values= c(0, 0, 0, 0),
                  name="matA0")
matG1 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=FALSE, # to identify the model config to zero
                  values=0,
                  name="matG1")
matG2 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=FALSE, # to identify the model config to zero
                  values=0,
                  name="matG2")

matV1 <- mxMatrix(type="Full", nrow=1, ncol=1, 
                  free=FALSE, 
                  labels="data.age", 
                  name = "age")
matV2 <- mxMatrix(type="Full", nrow=1, ncol=1, 
                  free=FALSE, 
                  labels="data.gender", 
                  name = "gender")

matIa <- mxMatrix(type="Diag", nrow=4, ncol=4, 
                  free=FALSE,
                  values=1, 
                  name="matIa")
matIb <- mxMatrix(type="Full", nrow=4, ncol=4, 
                  free=FALSE, 
                  values=c(0,1,1,1,
                           1,0,1,1,
                           1,1,0,1,
                           1,1,1,0),
                  name="matIb")
```

## Specify algebra for the dependent parameters
```{r}
matT <- mxAlgebra(expression=matT0+matB1*gender+matB2*age, 
                  name="matT")
matL <- mxAlgebra(expression=matL0+matC1*gender+matC2*age, 
                  name="matL")
matE <- mxAlgebra(expression=matE0*exp(matD1*gender+matD2*age), 
                  name="matE")
matA <- mxAlgebra(expression=matA0+matG1*gender+matG2*age, 
                  name="matA")

## Specify algebra for covariance matrix of factors (transformed to ensure positive definite matrices)
matVar <- mxAlgebra(expression=(matP0*exp(matH1*gender+matH2*age)), 
                    name="matVar")
matR <- mxAlgebra(expression=(exp(2*(matP0+matH1*gender+matH2*age))-1)/
                    (exp(2*(matP0+matH1*gender+matH2*age))+1), 
                  name="matR")
matCov <- mxAlgebra(expression=(matIa*sqrt(matVar))%*%matR%*%(matIa*sqrt(matVar)), 
                    name="matCov")
matP <- mxAlgebra(expression=matIa*matVar+matIb*matCov, 
                  name="matP")

## Specify model-implied matrices
matC <- mxAlgebra(expression=matL%*%matP%*%t(matL)+matE, 
                  name="matC") 
matM <- mxAlgebra(expression=matT+t(matL%*%matA), 
                  name="matM") 

## Specify expectation and fit function
expF <- mxExpectationNormal(covariance="matC", 
                            means="matM",
                            dimnames=manVars)
fitF <- mxFitFunctionML() 
```

## Make mxModel object and run the model
```{r}
modConfig <- mxModel(model="Configural", 
                     matT, matT0, matB1, matB2,
                     matL, matL0, matC1, matC2, 
                     matE, matE0, matD1, matD2,
                     matP, matP0, matH1, matH2,
                     matA, matA0, matG1, matG2,  
                     matIa, matIb, matV1, matV2, 
                     matVar, matR, matCov, matM, matC, 
                     expF, fitF, mxdf1)
```

```{r}
fitConfig <- mxRun(modConfig)
summary(fitConfig) 
```

```{r}
#mxCheckIdentification(modConfig) #commented out for knitting

```

### Specify matrices scalar model
```{r}
matB1 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                  free=FALSE,
                  values=0,
                  name="matB1")
matB2 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                  free=FALSE,
                  values=0,
                  name="matB2")
matC1 <- mxMatrix(type="Full", nrow=12, ncol=4,
                  free=FALSE,
                  values=0,
                  name="matC1")
matC2 <- mxMatrix(type="Full", nrow=12, ncol=4,
                  free=FALSE,
                  values=0,
                  name="matC2")

matH1 <- mxMatrix(type="Symm", nrow=4, ncol=4,
                  free=TRUE, 
                  values=0,
                  name="matH1")
matH2 <- mxMatrix(type="Symm", nrow=4, ncol=4,
                  free=TRUE, 
                  values=0,
                  name="matH2")

matG1 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=TRUE, 
                  values=0,
                  name="matG1")
matG2 <- mxMatrix(type="Full", nrow=4, ncol=1,
                  free=TRUE, 
                  values=0,
                  name="matG2")
```

## Make mxModel object and run the model
```{r}
modScalar <- mxModel(model="Scalar", 
                     matT, matT0, matB1, matB2,
                     matL, matL0, matC1, matC2, 
                     matE, matE0, matD1, matD2,
                     matP, matP0, matH1, matH2,
                     matA, matA0, matG1, matG2,  
                     matIa, matIb, matV1, matV2, 
                     matVar, matR, matCov, matM, matC, 
                     expF, fitF, mxdf1)
fitScalar <- mxRun(modScalar)
summary(fitScalar)
```

## Compare fit of unconstrained model with constrained model
```{r}
miTest <- mxCompare(fitConfig, fitScalar)
```

## Step 4: Select anchor indicators
```{r}
## Run unconstrained model for each indicator
fitAbo <- list()

for (i in 1:12) {
  freeparT <- matrix(FALSE, nrow = 1, ncol = 12)
  freeparT[i] <- TRUE
  
  freeparL <- matrix(FALSE, nrow = 12, ncol = 4)  # Adjusted for four number-spaces
  
  # Assign the corresponding number-space based on the row index
  if (i %in% 1:3) {
    freeparL[i, 1] <- TRUE  # First number-space
  } else if (i %in% 4:6) {
    freeparL[i, 2] <- TRUE  # Second number-space
  } else if (i %in% 7:9) {
    freeparL[i, 3] <- TRUE  # Third number-space
  } else if (i %in% 10:12) {
    freeparL[i, 4] <- TRUE  # Fourth number-space
  }       
  matB1 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                    free=freeparT,
                    values=0,
                    name="matB1")
  matB2 <- mxMatrix(type="Full", nrow=1, ncol=nv,
                    free=freeparT,
                    values=0,
                    name="matB2")
  matC1 <- mxMatrix(type="Full", nrow=12, ncol=4,
                    free=freeparL,
                    values=0,
                    byrow=TRUE,
                    name="matC1")
  matC2 <- mxMatrix(type="Full", nrow=12, ncol=4,
                    free=freeparL,
                    values=0,
                    byrow=TRUE,
                    name="matC2")
  modAbo <- mxModel(model=paste0("All_but_", i), 
                   matT, matT0, matB1, matB2,
                   matL, matL0, matC1, matC2, 
                   matE, matE0, matD1, matD2,
                   matP, matP0, matH1, matH2,
                   matA, matA0, matG1, matG2,  
                   matIa, matIb, matV1, matV2, 
                   matVar, matR, matCov, matM, matC, 
                   expF, fitF, mxdf1)
  fitAbo[[i]] <- mxRun(modAbo)
}
```

## Compare constrained model with all unconstrained models
```{r}
anchorTest <- mxCompare(fitAbo, fitScalar)
anchorOut <- data.frame(Name=paste0("Indicator",1:12), 
                    X2=anchorTest$diffLL[seq(2,24,2)],
                    df=anchorTest$diffdf[seq(2,24,2)],
                    p=anchorTest$p[seq(2,24,2)])
anchorOut
```

## Select two indicators per factor with smallest X2 as anchor
```{r}
anchorOut[order(anchorOut$X2[1:3]),]
anchorOut[3+order(anchorOut$X2[4:6]),]
anchorOut[6+order(anchorOut$X2[7:9]),]
anchorOut[9+order(anchorOut$X2[10:12]),]

## Save anchors in object ####currently random selected
anchors1 <- c(1,2)
anchors2 <- c(4,5)
anchors3 <- c(7,8)
anchors4 <- c(10,11)

```



